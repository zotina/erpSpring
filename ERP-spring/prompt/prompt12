    https://docs.frappe.io/erpnext/user/manual/en/introduction

    https://docs.frappe.io/hr/introduction
    baser votre reponse a ces documentation 
j ai cette process d insertion pour l import ces  3 csv : 

Ref	Nom	Prenom	genre	"Date embauche"	"date naissance"	company
1	Rakoto	Alain	Masculin	03/04/2024	01/01/1980	My Company
2	Rasoa	Jeanne	Feminin	08/06/2024	01/01/1990	My Company
						

"salary structure"	name	Abbr	type	valeur	Remarque
gasy1	Salaire Base	SB	earning	100%	
gasy1	Indemnité	IND	earning	30%	salaire base
gasy1	Taxe sociale	TS	deduction	20%	salaire base + indemnité
					
					
Mois	"Ref Employe"	"Salaire Base"	Salaire
01/04/2025	1	1500000	gasy1
01/04/2025	2	900000	gasy1
01/03/2025	1	1600000	gasy1
01/03/2025	2	900000	gasy1
	
et voici les fonctions pour l insertion de ce proceder 

import frappe
from frappe import _
from frappe.utils import getdate, flt
from datetime import datetime
from calendar import monthrange
from hrms.dto.employee_dto import EmployeeDTO
from hrms.dto.salary_structure_dto import SalaryStructureDTO
from hrms.dto.payroll_dto import PayrollDTO
from datetime import datetime

# =============================================================================
# PRE-TRANSACTION SETUP
# =============================================================================

def setup_hrms_data(employee_dtos: list[EmployeeDTO], salary_dtos: list[SalaryStructureDTO]):
    """
    Setup company with chart of accounts and default Holiday List.
    Args:
        employee_dtos: List of EmployeeDTO objects.
        salary_dtos: List of SalaryStructureDTO objects.
    Returns:
        List of errors (empty if successful).
    """
    errors = []

    try:
        # Setup companies and their accounts
        if employee_dtos:
            companies = set(employee.company for employee in employee_dtos if employee.company)
            
            for company in companies:
                if not company:
                    errors.append({
                        "line": 0,
                        "error_message": "Champ 'company' manquant ou invalide dans EmployeeDTO",
                        "data": {},
                        "file": "employeesCsv"
                    })
                    continue

                try:
                    # Normalize company name and suffix
                    company = company.strip()
                    company_suffix = 'MC' if company.lower().startswith('my company') else company[:2].upper()
                    print(f"Processing company: {company}, suffix: {company_suffix}")

                    # Verify reference company
                    ref_company = "noufre society"
                    if not frappe.db.exists("Company", ref_company):
                        ref_company = "_Test Company"
                        if not frappe.db.exists("Company", ref_company):
                            raise ValueError(f"Compagnie de référence '{ref_company}' n'existe pas")

                    # Create company if it doesn't exist
                    if not frappe.db.exists("Company", company):
                        print(f"Inserting company: {company}")
                        company_doc = frappe.new_doc("Company")
                        company_doc.company_name = company
                        company_doc.abbr = company_suffix
                        company_doc.default_currency = "EUR"
                        company_doc.create_chart_of_accounts_based_on = "Existing Company"
                        company_doc.existing_company = ref_company
                        company_doc.insert()
                        print(f"Created company: {company} with COA from {ref_company}")
                    else:
                        print(f"Company {company} already exists")

                    # Set default Holiday List for the company
                    holiday_list = get_or_create_holiday_list(company)
                    company_doc = frappe.get_doc("Company", company)
                    if not company_doc.default_holiday_list:
                        company_doc.default_holiday_list = holiday_list
                        company_doc.save()
                        print(f"Set default Holiday List '{holiday_list}' for company {company}")

                    # Find root account
                    root_account = frappe.db.get_value(
                        "Account",
                        {"company": company, "is_group": 1, "parent_account": ["is", None]},
                        "name"
                    )
                    if not root_account:
                        root_account_name = f"Root Account - {company_suffix}"
                        if not frappe.db.exists("Account", {"company": company, "account_name": "Root Account"}):
                            print(f"Inserting root account: {root_account_name}")
                            frappe.get_doc({
                                "doctype": "Account",
                                "account_name": "Root Account",
                                "company": company,
                                "is_group": 1,
                                "account_type": "",
                                "root_type": ""
                            }).insert()
                            root_account = root_account_name
                            print(f"Created fallback root account: {root_account_name} for {company}")
                        else:
                            root_account = frappe.db.get_value("Account", {"company": company, "account_name": "Root Account"}, "name")
                    print(f"Using root account: {root_account} for {company}")

                    # Setup HRMS accounts
                    def create_account_if_not_exists(account_name, parent_account, account_type, root_type, is_group=1):
                        existing_account = frappe.db.get_value(
                            "Account", 
                            {"company": company, "account_name": account_name}, 
                            "name"
                        )
                        if not existing_account:
                            try:
                                print(f"Inserting account: {account_name}")
                                account_doc = frappe.get_doc({
                                    "doctype": "Account",
                                    "account_name": account_name,
                                    "company": company,
                                    "parent_account": parent_account,
                                    "account_type": account_type,
                                    "root_type": root_type,
                                    "is_group": is_group
                                })
                                account_doc.insert()
                                print(f"Created account: {account_name}")
                                return account_doc.name
                            except Exception as e:
                                error_msg = f"Failed to create {account_name}: {str(e)}"
                                errors.append({
                                    "line": 0,
                                    "error_message": error_msg,
                                    "data": {},
                                    "file": "employeesCsv"
                                })
                                print(error_msg)
                                return None
                        else:
                            print(f"Account {account_name} already exists (name: {existing_account})")
                            return existing_account

                    income_root_name = create_account_if_not_exists(
                        "Income", root_account, "Income Account", "Income", 1
                    )
                    if not income_root_name:
                        continue

                    direct_income_name = create_account_if_not_exists(
                        "Direct Income", income_root_name, "Income Account", "Income", 1
                    )
                    if not direct_income_name:
                        continue

                    expenses_root_name = create_account_if_not_exists(
                        "Expenses", root_account, "Expense Account", "Expense", 1
                    )
                    if not expenses_root_name:
                        continue

                    direct_expenses_name = create_account_if_not_exists(
                        "Direct Expenses", expenses_root_name, "Expense Account", "Expense", 1
                    )
                    if not direct_expenses_name:
                        continue

                    salary_income_name = create_account_if_not_exists(
                        "Salary Income", direct_income_name, "Income Account", "Income", 0
                    )

                    salary_expense_name = create_account_if_not_exists(
                        "Salary Expense", direct_expenses_name, "Expense Account", "Expense", 0
                    )

                except Exception as e:
                    errors.append({
                        "line": 0,
                        "error_message": f"Erreur configuration compagnie {company}: {str(e)}",
                        "data": {},
                        "file": "employeesCsv"
                    })
                    print(f"Company setup error for {company}: {str(e)}")

        # Setup salary components
        if salary_dtos:
            for idx, salary in enumerate(salary_dtos, start=1):
                try:
                    component_name = salary.name if hasattr(salary, 'name') else salary.get('name')
                    component_type = salary.type if hasattr(salary, 'type') else salary.get('type')
                    company = next((e.company for e in employee_dtos if e.company), 'My Company')

                    if not component_name or not component_type:
                        errors.append({
                            "line": idx,
                            "error_message": f"Champ 'name' ou 'type' manquant dans SalaryStructureDTO à la ligne {idx}",
                            "data": vars(salary) if hasattr(salary, '__dict__') else salary,
                            "file": "salaryStructureCsv"
                        })
                        continue

                    if not isinstance(component_type, str):
                        errors.append({
                            "line": idx,
                            "error_message": f"Type invalide pour le composant {component_name} à la ligne {idx}: {component_type}",
                            "data": vars(salary) if hasattr(salary, '__dict__') else salary,
                            "file": "salaryStructureCsv"
                        })
                        continue

                    if not frappe.db.exists("Salary Component", component_name):
                        account_field = "default_income_account" if component_type.lower() == "earning" else "default_expense_account"
                        account = frappe.db.get_value("Account", {"company": company, "account_name": "Salary Income" if component_type.lower() == "earning" else "Salary Expense"}, "name")
                        if not account:
                            errors.append({
                                "line": idx,
                                "error_message": f"Compte requis non trouvé pour le composant {component_name}",
                                "data": vars(salary) if hasattr(salary, '__dict__') else salary,
                                "file": "salaryStructureCsv"
                            })
                            continue

                        salary_component_doc = frappe.get_doc({
                            "doctype": "Salary Component",
                            "salary_component": component_name,
                            "type": component_type.capitalize(),
                            account_field: account
                        })
                        salary_component_doc.insert()
                        print(f"Created salary component: {component_name} for {company}")

                except Exception as e:
                    errors.append({
                        "line": idx,
                        "error_message": f"Erreur création composant {component_name or 'inconnu'} à la ligne {idx}: {str(e)}",
                        "data": vars(salary) if hasattr(salary, '__dict__') else salary,
                        "file": "salaryStructureCsv"
                    })

    except Exception as e:
        errors.append({
            "line": 0,
            "error_message": f"Erreur configuration initiale: {str(e)}",
            "data": {},
            "file": "global"
        })

    return errors

# =============================================================================
# INSERTION DES EMPLOYÉS (FICHIER 1)
# =============================================================================
def insert_employees(dto_list: list[EmployeeDTO]):
    """
    Insert Employee records from EmployeeDTO list.
    Args:
        dto_list: List of EmployeeDTO objects.
    Returns:
        Dictionary with created records and errors.
    """
    created = []
    errors = []

    for idx, dto in enumerate(dto_list, start=1):
        try:
            # Validate required fields
            if not all([dto.ref, dto.prenom, dto.nom, dto.date_embauche, dto.date_naissance, dto.company]):
                raise ValueError("Champs requis manquants (ref, prenom, nom, date_embauche, date_naissance, company)")

            # Get default Holiday List for the company
            holiday_list = get_or_create_holiday_list(dto.company)

            # Prepare Employee data
            employee_data = {
                "doctype": "Employee",
                "ref": str(dto.ref),
                "name": str(dto.ref),
                "employee": str(dto.ref),
                "first_name": dto.prenom,
                "last_name": dto.nom,
                "gender": convert_gender(dto.genre),
                "date_of_joining": getdate(dto.date_embauche),
                "date_of_birth": getdate(dto.date_naissance),
                "company": dto.company,
                "status": "Active",
                "employee_name": f"{dto.prenom} {dto.nom}",
                "department": "Ressources humaines",
                "designation": get_or_create_designation("Employee"),
                "default_holiday_list": holiday_list  # Assign default Holiday List
            }

            # Check if employee exists
            if frappe.db.exists("Employee", {"employee": dto.ref}):
                errors.append({
                    "line": idx,
                    "error_message": f"Employé {dto.ref} existe déjà",
                    "data": vars(dto)
                })
                continue

            # Insert Employee
            employee_doc = frappe.get_doc(employee_data)
            employee_doc.insert()
            employee_doc.submit(    )
            print(f"Inserted employee: {employee_doc.ref}", "Employee Insertion")

            created.append({
                "employee_id": employee_doc.name,
                "employee_number": employee_doc.employee,
                "name": employee_doc.employee_name
            })

        except Exception as e:
            errors.append({
                "line": idx,
                "error_message": f"Erreur employé {dto.ref}: {str(e)}",
                "data": vars(dto)
            })
            print(f"Employee insertion failed: {dto.ref} - {str(e)}", "Employee Insertion Error")

    return {
        "success": len(errors) == 0,
        "created_count": len(created),
        "created": created,
        "errors": errors
    }
    
# =============================================================================
# INSERTION DES COMPOSANTS SALARIAUX (FICHIER 2)
# =============================================================================
def insert_salary_components(dto_list: list[SalaryStructureDTO]):
    """
    Insert Salary Component records from SalaryStructureDTO list.
    """
    created = []
    errors = []
    processed_components = set()

    for idx, dto in enumerate(dto_list, start=1):
        try:
            component_name = dto.name
            print(f"Processing salary component: {component_name} at line {idx}", "Component Debug")

            # Skip duplicates within the current list
            if component_name in processed_components:
                print(f"Skipping duplicate component in list: {component_name} at line {idx}", "Component Debug")
                continue

            if not component_name or not dto.type:
                errors.append({
                    "line": idx,
                    "error_message": f"Champ 'name' ou 'type' manquant pour composant à la ligne {idx}",
                    "data": vars(dto),
                    "file": "salaryStructureCsv"
                })
                continue

            # Check if component already exists in the database
            if frappe.db.exists("Salary Component", {"salary_component": component_name}):
                print(f"Salary component {component_name} already exists in database, skipping insertion", "Component Debug")
                created.append(component_name)
                processed_components.add(component_name)
                continue

            component_data = {
                "doctype": "Salary Component",
                "salary_component": component_name,
                "salary_component_abbr": dto.abbr or component_name[:3].upper(),
                "type": "Earning" if dto.type.lower() == "earning" else "Deduction",
                "is_tax_applicable": 1 if dto.type.lower() == "deduction" else 0
            }

            print(f"Inserting salary component: {component_name}", "Component Debug")
            component_doc = frappe.get_doc(component_data)
            component_doc.insert()
            component_doc.insert()

            created.append(component_name)
            processed_components.add(component_name)

        except Exception as e:
            errors.append({
                "line": idx,
                "error_message": f"Erreur composant {dto.name or 'inconnu'} à la ligne {idx}: {str(e)}",
                "data": vars(dto),
                "file": "salaryStructureCsv"
            })
            print(f"Component insertion error at line {idx}: {str(e)}", "Component Error")

    return {
        "success": len(errors) == 0,
        "created_count": len(created),
        "created": created,
        "errors": errors
    }
# =============================================================================
# INSERTION DES STRUCTURES SALARIALES (FICHIER 2)
# =============================================================================
def insert_salary_structures(dto_list: list[SalaryStructureDTO], payroll_dtos: list[PayrollDTO]):
    """
    Insert Salary Structure records from SalaryStructureDTO list, using company from matching PayrollDTO.
    Args:
        dto_list: List of SalaryStructureDTO objects.
        payroll_dtos: List of PayrollDTO objects to determine company.
    Returns:
        Dictionary with created records and errors.
    """
    structures_data = {}
    errors = []

    # Group components by structure
    for idx, dto in enumerate(dto_list, start=1):
        try:
            print(f"Processing salary structure DTO at line {idx}: name={dto.name}, structure={dto.salary_structure}", "Structure Debug")
            structure_name = dto.salary_structure
            if not structure_name:
                errors.append({
                    "line": idx,
                    "error_message": f"Champ 'salary_structure' manquant à la ligne {idx}",
                    "data": vars(dto) if hasattr(dto, '__dict__') else dict(dto),
                    "file": "salaryStructureCsv"
                })
                continue

            if structure_name not in structures_data:
                # Find matching payroll DTO to get company
                matching_payroll = next((p for p in payroll_dtos if p.salaire == structure_name), None)
                print(matching_payroll)
                company = None
                if matching_payroll:
                    # Get employee company from employee table
                    employee_data = frappe.db.get_value(
                        "Employee",
                        {"ref": str(matching_payroll.ref_employe)},
                        ["company"],
                        as_dict=True
                    )
                    company = employee_data.company if employee_data else None

                if not company:
                    company = "My Company"  # Fallback if no matching payroll or company
                    errors.append({
                        "line": idx,
                        "error_message": f"Compagnie non trouvée pour structure {structure_name}, utilisant 'My Company' par défaut",
                        "data": vars(dto) if hasattr(dto, '__dict__') else dict(dto),
                        "file": "salaryStructureCsv"
                    })

                structures_data[structure_name] = {
                    "earnings": [],
                    "deductions": [],
                    "company": company
                }

            component_data = {
                "salary_component": dto.name,
                "amount": parse_salary_value(dto.valeur),
                "formula": parse_salary_formula(dto.valeur, dto.remarque)
            }

            if dto.type and dto.type.lower() == "earning":
                structures_data[structure_name]["earnings"].append(component_data)
            elif dto.type:
                structures_data[structure_name]["deductions"].append(component_data)
            else:
                errors.append({
                    "line": idx,
                    "error_message": f"Type manquant pour composant {dto.name} à la ligne {idx}",
                    "data": vars(dto) if hasattr(dto, '__dict__') else dict(dto),
                    "file": "salaryStructureCsv"
                })

        except Exception as e:
            errors.append({
                "line": idx,
                "error_message": f"Erreur traitement structure à la ligne {idx}: {str(e)}",
                "data": vars(dto) if hasattr(dto, '__dict__') else dict(dto),
                "file": "salaryStructureCsv"
            })
            print(f"Structure processing error at line {idx}: {str(e)}", "Structure Error")

    created = []
    for structure_name, components in structures_data.items():
        try:
            if frappe.db.exists("Salary Structure", structure_name):
                errors.append({
                    "line": 0,
                    "error_message": f"Structure salariale {structure_name} existe déjà",
                    "data": components,
                    "file": "salaryStructureCsv"
                })
                continue

            structure_data = {
                "doctype": "Salary Structure",
                "name": structure_name,
                "structure_name": structure_name,
                "company": components["company"],
                "is_active": "Yes",
                "earnings": components["earnings"],
                "deductions": components["deductions"]
            }

            print(f"Inserting salary structure: {structure_data}", "Structure Insertion")

            structure_doc = frappe.get_doc(structure_data)
            structure_doc.flags.ignore_mandatory = True  # Bypass naming series
            structure_doc.insert()
            structure_doc.submit()

            created.append(structure_name)

        except Exception as e:
            errors.append({
                "line": 0,
                "error_message": f"Erreur insertion structure {structure_name}: {str(e)}",
                "data": components,
                "file": "salaryStructureCsv"
            })
            print(f"Structure insertion error for {structure_name}: {str(e)}", "Structure Error")

    return {
        "success": len(errors) == 0,
        "created_count": len(created),
        "created": created,
        "errors": errors
    }
# =============================================================================
# INSERTION DES ASSIGNATIONS SALARIALES (FICHIER 3)
# =============================================================================
def insert_salary_assignments(dto_list: list[PayrollDTO]):
    """
    Insert Salary Structure Assignment records from PayrollDTO list.
    """
    assignments_data = {}
    errors = []

    # Group by employee and determine the earliest date
    for idx, dto in enumerate(dto_list, start=1):
        try:
            employee_ref = dto.ref_employe
            converted_date = convert_date_format(dto.mois)
            if not converted_date:
                raise ValueError(f"Invalid date format for mois: {dto.mois}")

            if employee_ref not in assignments_data:
                assignments_data[employee_ref] = {
                    "salary_structure": dto.salaire,
                    "base_salary": dto.salaire_base,
                    "start_date": converted_date,
                    "line": idx
                }
            else:
                # Update start_date to the earliest date
                existing_date = assignments_data[employee_ref]["start_date"]
                if converted_date < existing_date:
                    assignments_data[employee_ref]["start_date"] = converted_date
        except Exception as e:
            errors.append({
                "line": idx,
                "error_message": f"Erreur traitement données assignation pour employé {dto.ref_employe}: {str(e)}",
                "data": vars(dto),
                "file": "payrollCsv"
            })

    created = []
    for employee_ref, assignment_data in assignments_data.items():
        try:
            # Get Employee details
            employee_data = frappe.db.get_value("Employee", {"ref": employee_ref}, ["name", "company", "date_of_joining"], as_dict=True)
            if not employee_data:
                errors.append({
                    "line": assignment_data["line"],
                    "error_message": f"Employé {employee_ref} non trouvé",
                    "data": assignment_data,
                    "file": "payrollCsv"
                })
                continue

            # Use date_of_joining if earlier than start_date
            from_date = assignment_data["start_date"]
            if employee_data.date_of_joining and employee_data.date_of_joining < getdate(from_date):
                from_date = employee_data.date_of_joining.strftime("%Y-%m-%d")

            # Check if Salary Structure exists
            structure_name = frappe.db.get_value("Salary Structure", {"structure_name": assignment_data["salary_structure"]}, "name")
            print(structure_name)
            if not structure_name:
                errors.append({
                    "line": assignment_data["line"],
                    "error_message": f"Structure salariale '{assignment_data['salary_structure']}' non trouvée",
                    "data": assignment_data,
                    "file": "payrollCsv"
                })
                continue

            # Check if assignment exists
            existing = frappe.db.exists("Salary Structure Assignment", {
                "employee": employee_data.name,
                "salary_structure": structure_name,
                "from_date": ["<=", from_date],
                "docstatus": 1
            })
            if existing:
                print(f"Assignment already exists for {employee_ref} with structure {assignment_data['salary_structure']}", "Assignment Debug")
                continue

            assignment_doc_data = {
                "doctype": "Salary Structure Assignment",
                "employee": employee_data.name,
                "salary_structure": structure_name,
                "from_date": from_date,
                "base": assignment_data["base_salary"],
                "company": employee_data.company
            }

            print(f"Inserting assignment for {employee_ref}: {assignment_doc_data}", "Assignment Debug")
            assignment_doc = frappe.get_doc(assignment_doc_data)
            assignment_doc.insert()
            assignment_doc.submit()  # Submit to set docstatus=1
            created.append(f"{employee_ref} -> {assignment_data['salary_structure']} from {from_date}")

        except Exception as e:
            errors.append({
                "line": assignment_data["line"],
                "error_message": f"Erreur assignation pour {employee_ref}: {str(e)}",
                "data": assignment_data,
                "file": "payrollCsv"
            })
            print(f"Assignment error for {employee_ref}: {str(e)}", "Assignment Error")

    return {
        "success": len(errors) == 0,
        "created_count": len(created),
        "created": created,
        "errors": errors
    }

# =============================================================================
# INSERTION DES BULLETINS DE PAIE (FICHIER 3)
# =============================================================================
def insert_salary_slips(dto_list: list[PayrollDTO]):
    """
    Insert Salary Slip records from PayrollDTO list.
    """
    created = []
    errors = []

    for idx, dto in enumerate(dto_list, start=1):
        try:
            # Get Employee
            employee = frappe.db.get_value("Employee", {"ref": dto.ref_employe}, "name")
            if not employee:
                errors.append({
                    "line": idx,
                    "error_message": f"Employé {dto.ref_employe} non trouvé",
                    "data": vars(dto),
                    "file": "payrollCsv"
                })
                continue

            # Convert date
            converted_date = convert_date_format(dto.mois)
            print(f"Processing salary slip for employee {dto.ref_employe} on date {converted_date}", "Salary Slip Debug")

            # Check if salary structure assignment exists
            assignment = frappe.db.get_value(
                "Salary Structure Assignment",
                {
                    "employee": employee,
                    "from_date": ["<=", converted_date],
                    "docstatus": 1
                },
                ["name", "salary_structure"],
                as_dict=True
            )
            if not assignment:
                errors.append({
                    "line": idx,
                    "error_message": f"Aucune structure salariale assignée à l'employé {dto.ref_employe} pour la date {dto.mois}",
                    "data": vars(dto),
                    "file": "payrollCsv"
                })
                continue

            # Check if Salary Slip exists
            existing = frappe.db.exists("Salary Slip", {
                "employee": employee,
                "start_date": converted_date
            })
            if existing:
                print(f"Salary slip already exists for {dto.ref_employe} on {converted_date}", "Salary Slip Debug")
                continue

            salary_slip_data = {
                "doctype": "Salary Slip",
                "employee": employee,
                "salary_structure": assignment.salary_structure,
                "start_date": converted_date,
                "end_date": get_month_end_date(dto.mois),
                "posting_date": converted_date,
                "company": "My Company"
            }

            print(f"Inserting salary slip: {salary_slip_data}", "Salary Slip Debug")
            slip_doc = frappe.get_doc(salary_slip_data)
            slip_doc.insert()
            slip_doc.submit()

            created.append(f"{dto.ref_employe} -> {dto.mois}")

        except Exception as e:
            errors.append({
                "line": idx,
                "error_message": f"Erreur bulletin {dto.ref_employe}: {str(e)}",
                "data": vars(dto),
                "file": "payrollCsv"
            })
            print(f"Salary slip error for {dto.ref_employe}: {str(e)}", "Salary Slip Error")

    return {
        "success": len(errors) == 0,
        "created_count": len(created),
        "created": created,
        "errors": errors
    }
# =============================================================================
# FONCTIONS UTILITAIRES
# =============================================================================
def convert_gender(genre):
    """Convert gender to ERPNext format."""
    genre_lower = genre.lower() if genre else ""
    if genre_lower in ['masculin', 'male', 'm']:
        return 'Male'
    elif genre_lower in ['feminin', 'female', 'f']:
        return 'Female'
    return 'Male'  # Default

def get_or_create_designation(designation_name):
    """Get or create a Designation."""
    if not frappe.db.exists("Designation", designation_name):
        desig_doc = frappe.get_doc({
            "doctype": "Designation",
            "designation_name": designation_name
        })
        desig_doc.insert()
    return designation_name

def parse_salary_value(valeur):
    """Parse salary value (percentage or amount)."""
    if valeur is None:
        print("parse_salary_value: valeur is None", "Value Debug")
        return 0
    try:
        valeur_str = str(valeur).strip()
        if not valeur_str or valeur_str.lower() == "none":
            return 0
        if '%' in valeur_str:
            return 0  # Use formula for percentages
        return flt(valeur_str)
    except Exception as e:
        print(f"parse_salary_value error: {str(e)} for valeur={valeur}", "Value Debug")
        return 0

def parse_salary_formula(valeur, remarque):
    """Parse salary formulas."""
    if valeur is None:
        print("parse_salary_formula: valeur is None", "Formula Debug")
        return ""
    try:
        valeur_str = str(valeur).strip()
        if not valeur_str or valeur_str.lower() == "none":
            return ""
        remarque_str = str(remarque).strip() if remarque else ""
        if '%' in valeur_str:
            percentage = valeur_str.replace('%', '').strip()
            pct = flt(percentage) / 100
            if 'salaire base' in remarque_str.lower():
                return f"base * {pct}"
            elif 'salaire base + indemnité' in remarque_str.lower():
                return f"(base + IND) * {pct}"
            else:
                return f"base * {pct}"
        return ""
    except Exception as e:
        print(f"parse_salary_formula error: {str(e)} for valeur={valeur}, remarque={remarque}", "Formula Debug")
        return ""

def get_month_end_date(date_str):
    """Get the end date of the month for a given date string."""
    try:
        # Convert DD/MM/YYYY to datetime object
        date_obj = datetime.strptime(date_str, '%d/%m/%Y')
        last_day = monthrange(date_obj.year, date_obj.month)[1]
        return f"{date_obj.year}-{date_obj.month:02d}-{last_day:02d}"
    except ValueError:
        try:
            # If already in YYYY-MM-DD format
            date_obj = datetime.strptime(date_str, '%Y-%m-%d')
            last_day = monthrange(date_obj.year, date_obj.month)[1]
            return f"{date_obj.year}-{date_obj.month:02d}-{last_day:02d}"
        except ValueError:
            raise ValueError(f"Invalid date format for get_month_end_date: {date_str}. Expected DD/MM/YYYY or YYYY-MM-DD.")

def convert_date_format(date_str):
    """Convert date from DD/MM/YYYY to YYYY-MM-DD or return as is if already in correct format."""
    if not date_str:
        return date_str
    try:
        # Try parsing DD/MM/YYYY format
        date_obj = datetime.strptime(date_str, '%d/%m/%Y')
        return date_obj.strftime('%Y-%m-%d')
    except ValueError:
        try:
            # If already in YYYY-MM-DD format, return as is
            datetime.strptime(date_str, '%Y-%m-%d')
            return date_str
        except ValueError:
            raise ValueError(f"Invalid date format: {date_str}. Expected DD/MM/YYYY or YYYY-MM-DD.")
        
        
def get_or_create_holiday_list(company, year=None):
    """
    Get or create a default Holiday List for the given company and year.
    Args:
        company: Name of the company.
        year: Year for the holiday list (default: current year).
    Returns:
        Name of the Holiday List.
    """
    if not year:
        year = datetime.now().year

    holiday_list_name = f"Default Holiday List - {company} - {year}"
    
    if not frappe.db.exists("Holiday List", holiday_list_name):
        try:
            holiday_list_doc = frappe.get_doc({
                "doctype": "Holiday List",
                "holiday_list_name": holiday_list_name,
                "from_date": f"{year}-01-01",
                "to_date": f"{year}-12-31",
                "weekly_off": "Sunday",  # Example: Set Sunday as weekly off
                "company": company
            })
            holiday_list_doc.insert()
            print(f"Created Holiday List: {holiday_list_name} for {company}")
        except Exception as e:
            raise Exception(f"Failed to create Holiday List for {company}: {str(e)}")
    
    return holiday_list_name 

cree moi un controller rest qui reset les donnees de cette procede :


puis appeler le sur mon application spring :

voici un model d afichage , service , controller et model de mon application spring : 


package mg.itu.controller;

import jakarta.servlet.http.HttpSession;
import mg.itu.model.HrmsCsvImportResponse;
import mg.itu.service.HrmsCsvImportService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;

@Controller
@RequestMapping("/api/hrms-csv-import")
public class HrmsCsvImportController {

    private static final Logger logger = LoggerFactory.getLogger(HrmsCsvImportController.class);

    @Autowired
    private HrmsCsvImportService hrmsCsvImportService;

    @GetMapping("/")
    public String getImportForm(Model model) {
        return "views/hrms-csv-import/hrms-csv-import";
    }

    @PostMapping("/import")
    public String importCsvFiles(
            @RequestParam("employeesCsv") MultipartFile employeesCsv,
            @RequestParam("salaryStructureCsv") MultipartFile salaryStructureCsv,
            @RequestParam("payrollCsv") MultipartFile payrollCsv,
            Model model,
            HttpSession session) {
        try {
            HrmsCsvImportResponse response = hrmsCsvImportService.importCsvFiles(
                    employeesCsv, salaryStructureCsv, payrollCsv, session);

            logger.debug("Response: status={}, success={}, message={}, validation_errors={}",
                    response.getStatus(), response.isSuccess(), response.getMessage(), response.getValidation_errors());
            logger.info("Model attributes: error={}, validationErrors={}",
                    model.getAttribute("error"), model.getAttribute("validationErrors"));

            if ("success".equals(response.getStatus()) || response.isSuccess()) {
                model.addAttribute("success", response.getMessageAsString());
                model.addAttribute("insertedRecords", response.getInserted_records());
            } else {
                model.addAttribute("error", response.getMessageAsString());
                model.addAttribute("validationErrors", response.getValidation_errors() != null ? response.getValidation_errors() : new java.util.ArrayList<>());
            }
        } catch (IllegalStateException e) {
            logger.warn("Authentication error: {}", e.getMessage());
            return "redirect:/api/auth/";
        } catch (Exception e) {
            logger.error("Error importing CSV files", e);
            model.addAttribute("error", "An error occurred while importing CSV files: " + e.getMessage());
            model.addAttribute("validationErrors", new java.util.ArrayList<>());
        }
        return "views/hrms-csv-import/hrms-csv-import";
    }
}

package mg.itu.model;

public class HrmsCsvImportRequest {
    private String employeesCsv;
    private String salaryStructureCsv;
    private String payrollCsv;

    
    public String getEmployeesCsv() {
        return employeesCsv;
    }

    public void setEmployeesCsv(String employeesCsv) {
        this.employeesCsv = employeesCsv;
    }

    public String getSalaryStructureCsv() {
        return salaryStructureCsv;
    }

    public void setSalaryStructureCsv(String salaryStructureCsv) {
        this.salaryStructureCsv = salaryStructureCsv;
    }

    public String getPayrollCsv() {
        return payrollCsv;
    }

    public void setPayrollCsv(String payrollCsv) {
        this.payrollCsv = payrollCsv;
    }
}

package mg.itu.model;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.util.List;
import java.util.Map;

@JsonIgnoreProperties(ignoreUnknown = true)
public class HrmsCsvImportResponse {
    private boolean success;
    private String message;
    private List<Map<String, Object>> validation_errors;
    private Map<String, List<Object>> inserted_records;
    private String status;

    // Handle nested message object
    @JsonProperty("message")
    private void unpackNestedMessage(Object nestedMessage) {
        if (nestedMessage instanceof Map) {
            Map<String, Object> map = (Map<String, Object>) nestedMessage;
            this.success = (Boolean) map.getOrDefault("success", false);
            this.message = (String) map.getOrDefault("message", "Unknown error");
            this.validation_errors = (List<Map<String, Object>>) map.get("validation_errors");
            this.inserted_records = (Map<String, List<Object>>) map.get("inserted_records");
        } else if (nestedMessage instanceof String) {
            this.message = (String) nestedMessage;
        }
    }

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public List<Map<String, Object>> getValidation_errors() {
        return validation_errors;
    }

    public void setValidation_errors(List<Map<String, Object>> validation_errors) {
        this.validation_errors = validation_errors;
    }

    public Map<String, List<Object>> getInserted_records() {
        return inserted_records;
    }

    public void setInserted_records(Map<String, List<Object>> inserted_records) {
        this.inserted_records = inserted_records;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getMessageAsString() {
        return message != null ? message : "Unknown error";
    }
}


package mg.itu.model;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
@JsonIgnoreProperties(ignoreUnknown = true)
public class ApiResponse<T> {
    private String status;
    private String message; 
    private List<T> data;

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public List<T> getData() {
        return data;
    }

    public void setData(List<T> data) {
        this.data = data;
    }
}

package mg.itu.model;

public class SingleApiResponse<T> {
    private String status;
    private String message;
    private T data; 

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}



package mg.itu.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpSession;
import mg.itu.model.HrmsCsvImportRequest;
import mg.itu.model.HrmsCsvImportResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.Base64;

@Service
public class HrmsCsvImportService {

    private static final Logger logger = LoggerFactory.getLogger(HrmsCsvImportService.class);

    @Autowired
    private WebClient.Builder webClientBuilder;

    @Value("${api.method}")
    private String baseApiUrl;

    private final ObjectMapper objectMapper = new ObjectMapper();

    public HrmsCsvImportResponse importCsvFiles(MultipartFile employeesCsv, MultipartFile salaryStructureCsv, 
                                               MultipartFile payrollCsv, HttpSession session) throws Exception {
        String accessToken = (String) session.getAttribute("access_token");
        String sid = (String) session.getAttribute("sid");

        if (accessToken == null || sid == null) {
            throw new IllegalStateException("User is not authenticated");
        }

        
        HrmsCsvImportRequest request = new HrmsCsvImportRequest();
        if (employeesCsv != null && !employeesCsv.isEmpty()) {
            request.setEmployeesCsv(Base64.getEncoder().encodeToString(employeesCsv.getBytes()));
            System.out.println("employeesCsv encoded, size: " + employeesCsv.getSize());
        }
        if (salaryStructureCsv != null && !salaryStructureCsv.isEmpty()) {
            request.setSalaryStructureCsv(Base64.getEncoder().encodeToString(salaryStructureCsv.getBytes()));
            System.out.println("salaryStructureCsv encoded, size: "+ salaryStructureCsv.getSize());
        }
        if (payrollCsv != null && !payrollCsv.isEmpty()) {
            request.setPayrollCsv(Base64.getEncoder().encodeToString(payrollCsv.getBytes()));
            System.out.println("payrollCsv encoded, size: "+ payrollCsv.getSize());
        }

        String url = baseApiUrl + "/hrms.controllers.hrms_controller.import_csvs_from_json";
        WebClient client = webClientBuilder.baseUrl(url).build();

        try {
            String requestBody = objectMapper.writeValueAsString(request);
            System.out.println("Sending request to {} with body: "+ requestBody);

            ResponseEntity<String> response = client.post()
                    .header("Authorization", "Bearer " + accessToken)
                    .cookie("sid", sid)
                    .header("Content-Type", "application/json")
                    .bodyValue(requestBody)
                    .retrieve()
                    .toEntity(String.class)
                    .block();

            if (response != null && response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                System.out.println("Received response: " + response.getBody());
                HrmsCsvImportResponse hrmsResponse = objectMapper.readValue(response.getBody(), HrmsCsvImportResponse.class);
                return hrmsResponse;
            }

            System.out.println("Received null or unsuccessful response:"+ response);
            HrmsCsvImportResponse errorResponse = new HrmsCsvImportResponse();
            errorResponse.setSuccess(false);
            errorResponse.setMessage("Failed to import CSV files");
            return errorResponse;

        } catch (Exception e) {
            logger.error("Error importing CSV files", e);
            HrmsCsvImportResponse errorResponse = new HrmsCsvImportResponse();
            errorResponse.setSuccess(false);
            errorResponse.setMessage("Error occurred: " + e.getMessage());
            return errorResponse;
        }
    }
}


<!DOCTYPE html>
<html lang="fr" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRMS CSV Import - DaybyDay</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
    <style>
        .upload-container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background-color: #f9fafb;
        }
        .upload-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .upload-container input[type="file"] {
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            width: 100%;
            margin-bottom: 15px;
        }
        .submit-btn {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .submit-btn:hover {
            background-color: #0056b3;
        }
        .response-container {
            margin-top: 20px;
        }
        .error-message, .success {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .error-message {
            background-color: #fee2e2;
            border: 1px solid #ef4444;
        }
        .success {
            background-color: #d1fae5;
            border: 1px solid #10b981;
        }
        .error-list {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff1f2;
            border: 1px solid #f43f5e;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div th:replace="~{fragments/side-bar}"></div>

    <div class="header">
        <div class="container">
            <h1>HRMS CSV Import</h1>
        </div>
    </div>

    <!-- Success/Error Messages -->
    <div th:if="${success}" class="success" th:text="${success}"></div>
    <div th:if="${error}" class="error-message">
        <strong th:text="${error}"></strong>
        <div th:if="${validationErrors != null and !validationErrors.isEmpty()}" class="error-list">
            <ul>
                <li th:each="error : ${validationErrors}">
                    <strong>Fichier: </strong><span th:text="${error.file}"></span><br/>
                    <strong>Ligne: </strong><span th:text="${error.line}"></span><br/>
                    <strong>Erreur: </strong><span th:text="${error.error_message}"></span><br/>
                    <strong>Données: </strong><span th:text="${error.data}"></span>
                </li>
            </ul>
        </div>
    </div>

    <!-- CSV Upload Form -->
    <div class="upload-container">
        <form th:action="@{/api/hrms-csv-import/import}" method="post" enctype="multipart/form-data">
            <div>
                <label for="employeesCsv">Employees CSV</label>
                <input type="file" id="employeesCsv" name="employeesCsv" accept=".csv" required/>
            </div>
            <div>
                <label for="salaryStructureCsv">Salary Structure CSV</label>
                <input type="file" id="salaryStructureCsv" name="salaryStructureCsv" accept=".csv" required/>
            </div>
            <div>
                <label for="payrollCsv">Payroll CSV</label>
                <input type="file" id="payrollCsv" name="payrollCsv" accept=".csv" required/>
            </div>
            <button type="submit" class="submit-btn">Import CSVs</button>
        </form>
    </div>

    <!-- Response Display -->
    <div class="response-container" th:if="${insertedRecords}">
        <h3>Inserted Records</h3>
        <div th:each="entry : ${insertedRecords}">
            <div class="success">
                <strong th:text="${entry.key}"></strong>
                <ul>
                    <li th:each="record : ${entry.value}" th:text="${record}"></li>
                </ul>
            </div>
        </div>
    </div>

    <div th:replace="~{fragments/footer}"></div>
</body>
</html>